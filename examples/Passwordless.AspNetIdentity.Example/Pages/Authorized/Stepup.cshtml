@page
@using Microsoft.AspNetCore.Mvc.TagHelpers
@using Microsoft.Extensions.Options
@using Passwordless.AspNetCore
@model StepUp
@inject IOptions<PasswordlessAspNetCoreOptions> PasswordlessOptions;

@{
    ViewData["Title"] = "Step Up";
}
<h1>@ViewData["Title"]</h1>

<p>Hello, @User.Identity!.Name</p>

<p>Please enter credentials to perform action.</p>

<input type="hidden" asp-for="StepUpVerifyToken" />

<button type="button" onclick="stepup('@Model.RequestedContext')">Proceed</button>

<script src="https://cdn.passwordless.dev/dist/1.1.0/umd/passwordless.umd.js"></script>
<script>
        const p = new Passwordless.Client({
           apiKey: "@PasswordlessOptions.Value.ApiKey",
           apiUrl: "@PasswordlessOptions.Value.ApiUrl"
       });
        
        async function stepup(context) {            
            // sign in begin
            const beginResponse = await signinBegin({ userId: '@Model.AuthenticatedUser!.Email'}, p);
            console.log(beginResponse);
            
            // get webauthn
            const credential = await navigator.credentials.get({
                publicKey: beginResponse.data,
                signal: p.abortController.signal,
            });
            
            // step up
            const stepUpPasskeyResponse = await stepupComplete(credential, beginResponse.session, context, p);
            
            const stepUpResponse = await fetch('/stepup', {
                method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            stepUpToken: stepUpPasskeyResponse.token, 
                            returnUrl: '@Model.ReturnUrl',
                            purpose: '@Model.RequestedContext'
                        })
                    });
            
            if (stepUpResponse.ok) {
                window.location.href = stepUpResponse.url;
            }
        }
        
        async function signinBegin(signinMethod, p) {
            const response = await fetch(`${p.config.apiUrl}/signin/begin`, {
                method: 'POST',
                headers: {
                    'ApiKey': `${p.config.apiKey}`,
                    'Content-Type': 'application/json',
                    'Client-Version': 'js-1.1.0'
                },
                body: JSON.stringify({
                    userId: "userId" in signinMethod ? signinMethod.userId : undefined,
                    alias: "alias" in signinMethod ? signinMethod.alias : undefined,
                    RPID: p.config.rpid,
                    Origin: p.config.origin,
                }),
            });
            
            const res = await response.json();
            if (response.ok) {
                return {
                    ...res,
                    data: {
                        ...res.data,
                        challenge: base64UrlToArrayBuffer(res.data.challenge),
                        allowCredentials: res.data.allowCredentials?.map((cred) => {
                            return {...cred, id: base64UrlToArrayBuffer(cred.id)};
                        })
                    }
                };
            }
            
            return {error: {...res, from: "server"}};
        }
        
        async function stepupComplete(credential, session, context, p) {
            const assertionResponse = credential.response;
            
            const response = await fetch(`${p.config.apiUrl}/stepup`, {
                method: 'POST',
                headers: {
                    'ApiKey': `${p.config.apiKey}`,
                    'Content-Type': 'application/json',
                    'Client-Version': 'js-1.1.0'
                },
                body: JSON.stringify({
                    session: session,
                    context: { context: context, timeToLive: 600 },
                    response: {
                        id: credential.id,
                        rawId: arrayBufferToBase64Url(new Uint8Array(credential.rawId)),
                        type: credential.type,
                        extensions: credential.getClientExtensionResults(),
                        response: {
                            authenticatorData: arrayBufferToBase64Url(assertionResponse.authenticatorData),
                            clientDataJson: arrayBufferToBase64Url(assertionResponse.clientDataJSON),
                            signature: arrayBufferToBase64Url(assertionResponse.signature),
                        },
                    },
                    RPID: p.config.rpid,
                    Origin: p.config.origin,
                })
            });
            
            const res = response.json()
            return response.ok
                ? res
                : {error: {...res, from: "server"} };
        }
        
        function arrayBufferToBase64Url(buffer) {
            const uint8Array = (() => {
                    if (Array.isArray(buffer)) return Uint8Array.from(buffer);
                    if (buffer instanceof ArrayBuffer) return new Uint8Array(buffer);
                    if (buffer instanceof Uint8Array) return buffer;
                    
                    const msg = "Cannot convert from ArrayBuffer to Base64Url. Input was not of type ArrayBuffer, Uint8Array or Array";
                    console.error(msg, buffer);
                    throw new Error(msg);
            })();
            
            let string = '';
            for (let i = 0; i < uint8Array.byteLength; i++) {
                string += String.fromCharCode(uint8Array[i]);
            }
            
            const base64String = window.btoa(string);
            return base64ToBase64Url(base64String);
        }
        
        function base64ToBase64Url(base64) {
            return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=*$/g, '');
        }
        
        function base64UrlToBase64(base64Url) {
            return base64Url.replace(/-/g, '+').replace(/_/g, '/');
        }
        
        function base64UrlToArrayBuffer(base64UrlString) {
            // improvement: Remove BufferSource-type and add proper types upstream
            if (typeof base64UrlString !== 'string') {
                const msg = "Cannot convert from Base64Url to ArrayBuffer: Input was not of type string";
                console.error(msg, base64UrlString);
                throw new TypeError(msg);
            }
            
            const base64Unpadded = base64UrlToBase64(base64UrlString);
            const paddingNeeded = (4 - (base64Unpadded.length % 4)) % 4;
            const base64Padded = base64Unpadded.padEnd(base64Unpadded.length + paddingNeeded, "=");
            
            const binary = window.atob(base64Padded);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            
            return bytes;
        }
    </script>

<p>This page requires an elevated authorization using the "elevated" context from step-up.</p>